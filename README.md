# Cpp-Examples
The C++ Project includes some examples and notes (mostly C++11). It also includes some additional examples/notes from the C++ How to Program (9th Edition) book.


**Notes**
- The `main` function is the designated start for program execution. All C++ programs must have a main function. If you try to compile a C++ program without a main function, the compiler raises an error. It can't be overloaded or declared an `inline` or `static` function. Also, it can't have its address taken, and can't be called from your program. It can be declared in different forms:
    1. `int main() {...}` which runs independently of environment-provided arguments.
    2. `int main(int argc, char *argv[]) {...}` which accepts environment provided arguments: 
        - `argc (Argument Count)` argument is a non-negative integer that contains the count of arguments that follow in `argv[]`
        - `argv[] (Argument Vector)` argument is an array of null-terminated strings representing command-line arguments entered by the user of the program. By convention, `argv[0]` is the command with which the program is invoked. So, `argv[0]` displays the program filename. `argv[1]` is the first command-line argument. The last argument from the command line is `argv[argc - 1]`, and `argv[argc]` is always **NULL**.
        - The size of the array pointed to by `argv` is at least `argc + 1`, and the last element, `argv[argc]`, is guaranteed to be a **NULL** pointer:
    3. `int main(/* implementation-defined */) {...}` which accepts implementation-defined type parameters. The C++ standards recommend implementation-defined main functions to place the extra (optional) parameters after `argv` argument.
- `endl` manipulator inserts a **newline** and flushes the stream.
- **Header** files shouldn't include namespaces.
- **unsigned** keyword allows the variable to be only a positive. The integer can never be a negative value.
- `default_random_engine` - `srand` functions change the seed(starting point) of the random number generator algorithm.
- [`float (4)`, `long (4)`, `double (8)`, `long double (8)`](https://learn.microsoft.com/en-us/cpp/cpp/fundamental-types-cpp?view=msvc-170#sizes-of-built-in-types)
- Stack: LIFO, Queue: FIFO.
- The ampersand(&) is used in variable declarations to declare reference variable.
- **Overloaded Function**: Function overloading is a feature of OOP where the multiple functions with the same name has different parameter data types.
- **Temporary** is a construct that generates an ordinary type or function at compile time based on arguments the user supplies for the **template** parameters. They are described as `template <typename T>` or `template<class T>`. `typename` and `class` keywords can be used interchangeably.
- **Performance Concern**: If the performance is important, then better to avoid using recursion functions. It takes more time and uses more memory. The deeper the recursion, the more memory is used. Because each recursive call requires its own stack frame to store variables and other information.
- `vector.insert()` and `vector.emplace` are used for the same purpose. However;
    - `emplace` constructs an object in place at a specified position, potentially **avoiding a copy operation**.
    - `insert` adds a **copy** of the object at the specified position.
- `std::vector::begin` returns a **read/write** iterator that points to the first element in the vector.
- `std::vector::end` returns a **read/write** iterator that points to the last element in the vector.
- `std::vector::cbegin` returns a **read-only** iterator that points to the first element in the vector.
- `std::vector::crend` returns a **read-only** reverse iterator that pointsto one before the first element in the vector.
- `std::vector::crbegin` returns a **read-only** reverse iterator that points to the last element in the vector.
- `std::vector::cend` returns a **read-only** iterator that points to the last element in the vector.
- It is important to set a default value like `nullptr` to the pointers. It might cause critical issues to update a pointer that doesn't have a default value since the value might not point to a valid memory location.
- `lvalue` simply means an object that has an identifiable location in memory.
- `r-value` simply means, an object that has no identifiable location in memory.
- `char` array constants have a static storage duration (they exist throughout the program).
- The `~` operator is used to reverse operation on the bytes so it makes sense to use it for `destructor` function definitions like `~Destroy()`
- When a variable is declared as `static`, space for it gets allocated for the lifetime of the program. The space for the static variable is allocated only once.
- A `static` variable of a class, gets allocated once so it stores one value for each generated same type class. So, it isn't used to store special values for each class. It stores the class specific global variables.
- The `static` variable can't be defined with `const` since `const` keyword means that it can't change the objects in the function/class in which it is defined. However, the `static` variables are independent of the class objects
- Objects are created from the inside out and destroyed from the outside in via `destructor` functions.
- The `friend` class/function can access private and protected members of a class. The parameter object that references the class must be a constant. 
    - `friend` functions in the class have permission to access any property(public/protected/private) of the class which it is defined
    - `friend` class have permission to access public/private/protected members of other classes in which it is declared as a friend 
- Using `this->` is same with `(*this).`. Because the dot(.) operator is prioritized higher than the asterisk(*) operator, it is necessary to use parentheses.
- The operators can be overloaded to customize some functionalities. It is like overloading the `<<` operator to print a text specifically by the class requirements or the `++` operator to update a character in the text instead of increasing the number.
- `struct` keyword allows us to create structures. Structures are a way to group several related variables into one place like an object and can contain different data types:
    ```c++
    struct str {
        int num;
        string text;
        ...
    }
    ```
- A memory leak occurs when new memory is allocated dynamically and never deallocated. In `C` programs, new memory is allocated by the `malloc` or `calloc` functions, and deallocated by the `free` function. In C++, new memory is usually allocated by the `new` operator and deallocated by the `delete` or the `delete []` operator. The list variables should be deallocated by the `delete []` since it guarantees to call all of the elements in the list. Similarly, use `delete` to deallocate the memory that is defined as a single element. Using `delete []` to deallocate the single memorized element is undefined. 
- `friend` functions can't be inherited in C++. If the base class has any friend function, this function doesnâ€™t become the friend of the derived class.
- `Polymorphism` means having multiple forms. To adapt `polymorphism` in inherited classes, `override` an inherited function in the derived class by defining a function with the same prototype of the overridden function and using `override` keyword. 
- When declaring a function with `override` keyword, the compiler checks whether the base class has the same function that has the same signature(same name, parameters). If it doesn't exist, then the compiler shows error. Also, the base class must be declared as a `virtual` function to enable dynamic overriding.
- `virtual` functions cannot be `static` but can be a `friend` function of another class. Also, the constructors can't be defined as `virtual` cause virtual pointer doesn't define when the constructor of the class is executed.
- About the difference between `virtual` and `abstract` functions, the `virtual` function must have a base functionality(body) so, it provides the derived classes with the option of overriding it. However, this is not mandatory. When it is not overridden, it uses the base function that is defined as default. However, the `abstract` function is defined without any functionality(body) as default so it has to be overridden by the (non-abstract) subclasses. This override process is mandatory unlike the `virtual` functions.
- `final` specifier is used to prevent overriding of a virtual function. 
- If a class that is defined with a `final` specifier, can't be a base class. So, the classes with `final` specifier, don't allow inheritance. 
- For the inherited classes;
    - When an object of the **derived class** is created, the constructor of the **base class** executes first. Then, the constructor of the **derived class** executes. If there is a deeper inheritance hierarchy, then this flow executes in the same order **(cascade)**.
    - In the opposite way, when the **derived class's object** is destroyed, the destructors are called in the **reverse order of the constructors**. So, the destructor function of the derived class executes first, followed by execution of the destructor of the base class.
- One of the advantages of OOP is code reuse. There are two ways we can do code reuse either by the implementation of inheritance (`is-a` relationship), or object composition (`has-a` relationship)
    - A `is-a` relation is based on inheritance. For example, **Car** (derived) class has `is-a` relation with the **Vehicle** (base) class. In short, the **Car** class is a sub-class of **Vehicle** class, so it can be described similarly as `Car class is a (subclass of) Vehicle class`.
    - A `has-a` relation is based on composition. For example, **Car** class has `has-a` relation with the `Wheel` and `Brakes` classes. In short, **Wheel** and **Brakes** are parts of a **Car**, so it can be described similarly as `Car has wheel and brakes`.
- `typeid` operator returns the runtime type information of the parameter like a data type. For a class defined variable, it returns the information of the class (e.g. `typeid(...).name()` returns the class name).
- The `typedef` keyword is used to create customized data types with aliased names. For example;
    - `istream` type definition represents the `basic_istream<char>` template customization. `typedef` keyword is used like `typedef basic_istream<char> istream;`
    - `ostream` type definition represents the `basic_istream<char>` template customization. `typedef` keyword is used like `typedef basic_ostream<char> ostream;`
    - A customized `pointer` definition could be defined like `typedef Person * personPtr;`
    - A customized `vector` definition could be defined like `typedef std::vector<Person> vPerson;`
    - A customized `vector pointer` definition could be defined like `typedef std::vector<Person *> vPersonPtr;`
    - A customized `function` definition could be defined like `typedef void (* personFunctionPtr)(std::char, int);`
- The `string_view` template specialization provides an efficient way to pass a **read-only(constant)**, **exception-safe**, **non-owning handle** to the character data of any string. It is optimized for the constant string operations. For example, when declaring constant(enum) strings that shouldn't be modified anywhere, it is a good choice.
- `constexpr` keyword improves program performance by computing at compile time rather than run time. Unlike `const`, `constexpr` can also be applied to **functions** and **class** constructors.
- `boolalpha` manipulator formats and displays the `boolean` variables in text format (`true` for `1`, and `false` for `0`). Using `noboolalpha` manipulator disables this feature so it displays as `1` or `0` as in normal.
- `showpoint` manipulator is used to show(fill) the zeros of the decimal value. So, the variable could be displayed in a certain length. For example, a float variable with the `2.300` value shows as `2.3` in normal. By setting the `showpoint` manipulator, it shows as `2.30000`. Setting the `precision` function declares how many characters will be displayed in total, so the zeros could be limited. After setting `setprecision(5)`, it shows as `2.3000`. On the other hand, using the `noshowpoint` manipulator disables this feature, so the decimal point is only displayed for numbers whose decimal part is not zero as in normal.
- `scientific` manipulator is used to display the numbers in scientific notations.
- `cin.fail()` method is used to check whether the entered input type is the same as the variable type. If it's not in the same data type, it returns 1. Otherwise, returns 0.
- `#define` **preprocessor** directive is used to define a `macro`(constant). `Macros` are a way to represent a fragment of code or a constant value by giving it a name. When the **preprocessor** encounters the `macro` name in the code, it replaces it with the corresponding code fragment or value that is defined using the #define **preprocessor**.
- `std::ofstream` **(Output File Stream)** is used to write into files. `std::ifstream` **(Input File Stream)** is used to read the data from a file.
- `std::ios` is a base class for all stream classes using narrow char characters. Both this class and its parent class `ios_base`, define the components of streams that do not depend on whether the stream is an input or an output stream.
- `std::ios::app` writes the new lines to the end of the file. So, the previous data in the file remains.
- `std::ios::out` opens file for writing and deletes the previous data in the file. It writes the new data instead.
- `std::ios::in` opens file for reading and allows inputs from the stream to get the data in the file.
- `std::ios::binary` opens the file in binary mode. 
- **Iterators** are used to access and iterate through elements of data structures. `std::istream_iterator` provides input iterator semantics for streams. `std::ostream_iterator` provides output iterator semantics for streams.
- `std::splice` carries the elements of the list to the other one and purges the elements from the main list.
- `std::merge` carries the elements of the list to the other one **as sorted** and purges the elements from the main list.
- `std::unique` removes the duplicates.
- `std::remove` removes the element in the list equal to value(parameter).
- `std::priority_queue` sorts the elements automatically and locates the biggest value to the top(front) of the queue. It is available to sort it descending and locate the lowers value to the top(front) by settings the 3.(`_Compare`) parameter. The default of it is `less`. The other options are: `equal_to`, `not_equal_to`, `greater`, `greater_equal`, `less_equal`.
- `equal_range` function returns a `std::pair` containing a pair of iterators as **pair::first** and **pair::second**. 
    - The `pair::first` value is the same as the `upper_bound` function returns. `upper_bound` is a built-in function used to find the first element in a sorted range that is strictly greater than a given value. 
    - The `pair::second` value is the same as the `lower_bound` function returns. `lower_bound` is a built-in function used to find the position of an element in a sorted range that has a value not less than the given value.
- `std::bitset` represents a fixed-size sequence of N bits(each bit occupies 1 bit of memory).
    - `set()` sets a given bit(1 or 0) to a particular value.
    - `flips()` toggles every bit to its opposite value(1 to 0, 0 to 1).
    - `reset()` sets every bit to false(0).
    - `size()` returns the total number of bits.
    - `count()` returns the number of bits which are set(1).
    - `any()` checks whether **any** of the bits are on(1) and returns true if all the bits are set as 1. Otherwise, returns false.
    - `all()` checks whether **all** of the bits are on(1) and returns true if all the bits are set as 1. Otherwise, returns false.
    - `none()` checks whether **any** of the bits are on(1) and returns true if none of the bits are set as 1. Otherwise, returns false.
    - `test()` checks the value of a bit and returns value at position. Returns 1 if the value is 1. Otherwise, returns 0.
    - `bit1 &= bit2` performs binary logical AND operator and sets result into the `bit1`.
    - `bit1 |= bit2` performs binary logical OR operator and sets result into the `bit1`.
    - `bit1 ^= bit2` performs binary logical XOR operator and sets result into the `bit1`.
    - `~bit1` performs binary logical NOT operator and flips the bits to opposite (1 to 0 or 0 to 1).
    - `>>=` shifts the bits N step right.
    - `<<=` shifts the bits N step left.
    - `to_string()` converts bits to a string.
    - `to_ulong()` returns a numerical interpretation (the integral equivalent of the bits) of the bitset by converting the bitset to an **unsigned long**.
- The header `<algorithm>` defines a collection of functions especially designed to be used on ranges of elements. Some functions in `<algorithm>`:
    - `equal` function compares whether the values are equal.
    - `mismatch` function returns a pair of iterators. The pair's first iterator is the first array's unmatched first value. The pair's second iterator is the unmatched first value in the second array.
    - `remove` function removes all elements equal to the value(parameter).
    - `remove_copy` function removes all elements equal to the value(parameter) and copies new sequence to the other one.
    - `remove_if` function removes elements for which `predicate` function returns true.
    - `remove_copy_if` function removes elements for which `predicate` function returns true and copies new sequence to the other one.
    - `replace` function replaces each element of one value with another value.
    - `replace_copy` function replaces each element of one value with another value and copies new sequence to the other one.
    - `replace_if` function replaces each element for which a predicate returns true with another value.
    - `replace_copy_if` function replaces each element for which a predicate returns true with another value and copies new sequence to the other one.
- Notes of some **mathematical algorithm** functions:
    - `fill_n` function is used to fill the N elements with a given default value.
    - `random_shuffle` randomly shuffle the elements of a sequence.
    - `count` counts the number of copies of a value in a sequence.
    - `count_if` counts the elements of a sequence for which a predicate is true.
    - `minmax_element` return a pair of iterators pointing to the minimum and maximum elements in a range. `first` ==> min value, `second` ==> max value
        - `min_element` returns the minimum element in the range.
        - `min` returns the minimum value.
        - `max_element` returns the maximum element in the range.
        - `max` returns the maximum value.
    - `accumulate` accumulates values in the range.
    - `for_each` applies a function to every element of a sequence.
    - `transform` function performs an operation to all elements in the array and, transforms the new elements to a new array.
    - `find_if` finds the first element in a sequence for which a predicate is true.
    - `find_if_not` finds the first element in a sequence for which a predicate is false.
    - `binary_search` searches the value in the array and returns bool whether the value is in the array.
    - `all_of` checks whether the predicate function returns **true** for **all** of the elements.
    - `any_of` checks whether the predicate function returns **true** for **any** of the elements.
    - `none_of` checks whether the predicate function returns **false** for **all** of the elements.
    - `swap` swaps the elements with the each other.
    - `iter_swap` uses iterator to swap the elements with the each other by the indexes.
    - `swap_ranges` swaps each element in the range with the corresponding element in the range. The ranges must not overlap.
    - `unique_copy` removes the **consecutive** duplicate values and copies result to a sequence.
    - `unique` removes the **consecutive** duplicate values from the related array.
    - `copy_backward` copies the elements to the other sequence. It has the same effect as `copy`, but starts at the end of the range and works its way to the start, returning the start of the result.
    - `merge` merges two sorted ranges in one.
    - `reverse` reverses the sequence.
    - `includes` checks whether a sequence is a subsequence of the other one. It returns true if the sequence elements include the other sequence's elements.
    - `set_difference` returns the difference of two sorted ranges.
    - `set_intersection` returns the intersected elements of two sorted ranges.
    - `set_symmetric_difference` returns the symmetric difference(The values which are in the array and not in merged array, or in merged array and not in main array) of two sorted ranges.
    - `set_union` returns the union(The values which exist in one or both of the sequences) of two sorted ranges. 
    - `equal_range` finds the lower and upper bound values and returns them as a pair.
        - `lower_bound` finds the first value that is lower than or equal to the value.
        - `upper_bound` finds the first value that is upper than the value.
    - `is_heap` function determines whether the any elements in the range is a heap.
    - `is_heap_until` searchs the end of a heap and returns an iterator pointing to the first element not in the heap.
    - `make_heap` constructs a heap in the range of the array.
    - `sort_heap` sort the elements in the heap.
- `lambda` expressions are a convenient way of defining an anonymous function object (a closure) right at the location where it's invoked or passed as an argument to a function. Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms or asynchronous functions.
- `noexcept` expression specifies whether a function could throw exceptions. It is a suffix to a function declaration that represents a set of types that might be matched by an exception handler for any exception that exits a function.
- `set_new_handler` takes a replacement handler as the argument, returns the
previous handler. The newly configured handler function is the function called by allocation functions whenever a memory allocation attempt fails. It transfers control to your error-handling mechanism if the new operator fails to allocate memory. So, it allows us to catch and manage the memory allocation issues.
- `overflow_error` specifies the arithmetic overflow errors for the situations in which a result of an arithmetic computation is too large for the destination type.
- `underflow_error` specifies the arithmetic underflow errors for the situations in which the result of an arithmetic computation is less than the smallest value that can be stored in the computer.
- `abort` function aborts the execution and generate a core-dump.
- `unique_ptr` is a **smart pointer** that automatically manages the dynamically allocated resources on the heap via a pointer. 
    - A unique pointer can point to only one resource(a single object or dynamically allocated array of objects). 
    - A `unique_ptr` can transfer the ownership of the managed object to another unique_ptr if it's not declared as const. 
    - A `unique_ptr` variable is created by using the **new** keyword, so it allocates dynamically. So, it must be freed by using the `delete` keyword. As the name suggests, the unique pointers free the dynamically allocated resource memory automatically when the destructor function is called, so it avoids the dynamically allocated resource memory issues.
- The last pointer of the linked data structure must point to a **NULL pointer** to mark the end of the list. Each node is connected with the next one and the last node doesn't have any node after itself so it can't point to other next node.
- Defining **Dynamic Memory Allocation** for the data structures that grow and shrink, saves memory. 